---
description: 
globs: 
alwaysApply: false
---
# EStore API Endpoints Rules

// ... existing code ...

## Validation
- Use FluentValidation for all request validation
- Create separate validator classes for each request model
- Place validators in the same folder as the endpoint
- Use the following naming convention: `{RequestName}Validator`

### FluentValidation Implementation
```csharp
// Example validator structure
public class CreateProductRequestValidator : AbstractValidator<CreateProductRequest>
{
    public CreateProductRequestValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty()
            .MaximumLength(100)
            .WithMessage("Product name must not exceed 100 characters");

        RuleFor(x => x.Price)
            .GreaterThan(0)
            .LessThanOrEqualTo(1000000)
            .WithMessage("Price must be between 0.01 and 1,000,000");

        RuleFor(x => x.Description)
            .MaximumLength(1000)
            .When(x => !string.IsNullOrEmpty(x.Description))
            .WithMessage("Description must not exceed 1000 characters");
    }
}

// Endpoint with validation
public class CreateProduct : IEndpoint
{
    public void MapEndpoint(IEndpointRouteBuilder app)
    {
        app.MapPost("/api/products", async (
            CreateProductRequest request,
            IValidator<CreateProductRequest> validator,
            IMediator mediator,
            CancellationToken cancellationToken) =>
        {
            var validationResult = await validator.ValidateAsync(request, cancellationToken);
            if (!validationResult.IsValid)
            {
                return Results.ValidationProblem(validationResult.ToDictionary());
            }

            var command = new CreateProductCommand(request);
            var result = await mediator.Send(command, cancellationToken);
            return Results.Ok(result);
        })
        .WithName("CreateProduct")
        .WithTags("Products");
    }
}
```

### Validation Best Practices
1. **Validator Organization**
   - Keep validators close to their corresponding request models
   - Use inheritance for shared validation rules
   - Consider using extension methods for common validation patterns

2. **Validation Rules**
   - Use descriptive error messages
   - Implement custom validation rules when needed
   - Use `When` conditions for conditional validation
   - Consider using `Must` for complex validation logic

3. **Error Handling**
   - Convert validation results to ProblemDetails format
   - Include all validation errors in the response
   - Use consistent error message formatting

4. **Performance**
   - Use async validation when needed
   - Consider caching validation results for frequently used validators
   - Avoid expensive operations in validation rules

// ... existing code ...